{"version":3,"file":"chartjs-plugin-annotation.min.js","sources":["../GitHub/Chart.js/helpers/core.js","src/types/box.js","src/types/line.js","../GitHub/Chart.js/helpers/extras.js","src/annotation.js","../GitHub/Chart.js/helpers/canvas.js","src/index.js"],"sourcesContent":["/*!\n * Chart.js v3.0.0-beta\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\nfunction noop() {}\nconst uid = (function() {\n\tlet id = 0;\n\treturn function() {\n\t\treturn id++;\n\t};\n}());\nfunction isNullOrUndef(value) {\n\treturn value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n\tif (Array.isArray && Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tconst type = Object.prototype.toString.call(value);\n\tif (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n\t\treturn true;\n\t}\n\treturn false;\n}\nfunction isObject(value) {\n\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction valueOrDefault(value, defaultValue) {\n\treturn typeof value === 'undefined' ? defaultValue : value;\n}\nfunction callback(fn, args, thisArg) {\n\tif (fn && typeof fn.call === 'function') {\n\t\treturn fn.apply(thisArg, args);\n\t}\n}\nfunction each(loopable, fn, thisArg, reverse) {\n\tlet i, len, keys;\n\tif (isArray(loopable)) {\n\t\tlen = loopable.length;\n\t\tif (reverse) {\n\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t}\n\t\t}\n\t} else if (isObject(loopable)) {\n\t\tkeys = Object.keys(loopable);\n\t\tlen = keys.length;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t}\n\t}\n}\nfunction _elementsEqual(a0, a1) {\n\tlet i, ilen, v0, v1;\n\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\treturn false;\n\t}\n\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\tv0 = a0[i];\n\t\tv1 = a1[i];\n\t\tif (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction clone(source) {\n\tif (isArray(source)) {\n\t\treturn source.map(clone);\n\t}\n\tif (isObject(source)) {\n\t\tconst target = {};\n\t\tconst keys = Object.keys(source);\n\t\tconst klen = keys.length;\n\t\tlet k = 0;\n\t\tfor (; k < klen; ++k) {\n\t\t\ttarget[keys[k]] = clone(source[keys[k]]);\n\t\t}\n\t\treturn target;\n\t}\n\treturn source;\n}\nfunction _merger(key, target, source, options) {\n\tconst tval = target[key];\n\tconst sval = source[key];\n\tif (isObject(tval) && isObject(sval)) {\n\t\tmerge(tval, sval, options);\n\t} else {\n\t\ttarget[key] = clone(sval);\n\t}\n}\nfunction merge(target, source, options) {\n\tconst sources = isArray(source) ? source : [source];\n\tconst ilen = sources.length;\n\tif (!isObject(target)) {\n\t\treturn target;\n\t}\n\toptions = options || {};\n\tconst merger = options.merger || _merger;\n\tfor (let i = 0; i < ilen; ++i) {\n\t\tsource = sources[i];\n\t\tif (!isObject(source)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst keys = Object.keys(source);\n\t\tfor (let k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\tmerger(keys[k], target, source, options);\n\t\t}\n\t}\n\treturn target;\n}\nfunction mergeIf(target, source) {\n\treturn merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n\tconst tval = target[key];\n\tconst sval = source[key];\n\tif (isObject(tval) && isObject(sval)) {\n\t\tmergeIf(tval, sval);\n\t} else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n\t\ttarget[key] = clone(sval);\n\t}\n}\nfunction _deprecated(scope, value, previous, current) {\n\tif (value !== undefined) {\n\t\tconsole.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n\t}\n}\nfunction resolveObjectKey(obj, key) {\n\tif (key.length < 3) {\n\t\treturn obj[key];\n\t}\n\tconst keys = key.split('.');\n\tfor (let i = 0, n = keys.length; i < n; ++i) {\n\t\tconst k = keys[i];\n\t\tif (k in obj) {\n\t\t\tobj = obj[k];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\treturn obj;\n}\nfunction _capitalize(str) {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport { _capitalize, _deprecated, _elementsEqual, _merger, _mergerIf, callback, clone, each, isArray, isNumberFinite as isFinite, isNullOrUndef, isObject, merge, mergeIf, noop, resolveObjectKey, uid, valueOrDefault };\n","import {Element} from 'chart.js';\r\n\r\nexport default class BoxAnnotation extends Element {\r\n\tinRange(mouseX, mouseY, useFinalPosition) {\r\n\t\tconst {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\r\n\r\n\t\treturn mouseX >= x &&\r\n\t\t\tmouseX <= x + width &&\r\n\t\t\tmouseY >= y &&\r\n\t\t\tmouseY <= y + height;\r\n\t}\r\n\r\n\tgetCenterPoint(useFinalPosition) {\r\n\t\tconst {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\r\n\t\treturn {\r\n\t\t\tx: x + width / 2,\r\n\t\t\ty: y + height / 2\r\n\t\t};\r\n\t}\r\n\r\n\tdraw(ctx) {\r\n\t\tconst {x, y, width, height, options} = this;\r\n\r\n\t\tctx.save();\r\n\r\n\t\tctx.lineWidth = options.borderWidth;\r\n\t\tctx.strokeStyle = options.borderColor;\r\n\t\tctx.fillStyle = options.backgroundColor;\r\n\r\n\t\tctx.fillRect(x, y, width, height);\r\n\t\tctx.strokeRect(x, y, width, height);\r\n\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\nBoxAnnotation.id = 'boxAnnotation';\r\n\r\nBoxAnnotation.defaults = {\r\n\tborderWidth: 1\r\n};\r\n\r\nBoxAnnotation.defaultRoutes = {\r\n\tborderColor: 'color',\r\n\tbackgroundColor: 'color'\r\n};\r\n\r\n/*\r\nfunction(Chart) {\r\n\tvar helpers = require('../helpers.js')(Chart);\r\n\r\n\tvar BoxAnnotation = Chart.Annotation.Element.extend({\r\n\t\tsetDataLimits: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\tvar options = this.options;\r\n\t\t\tvar chartInstance = this.chartInstance;\r\n\r\n\t\t\tvar xScale = chartInstance.scales[options.xScaleID];\r\n\t\t\tvar yScale = chartInstance.scales[options.yScaleID];\r\n\t\t\tvar chartArea = chartInstance.chartArea;\r\n\r\n\t\t\t// Set the data range for this annotation\r\n\t\t\tmodel.ranges = {};\r\n\r\n\t\t\tif (!chartArea) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar min = 0;\r\n\t\t\tvar max = 0;\r\n\r\n\t\t\tif (xScale) {\r\n\t\t\t\tmin = helpers.isValid(options.xMin) ? options.xMin : xScale.getValueForPixel(chartArea.left);\r\n\t\t\t\tmax = helpers.isValid(options.xMax) ? options.xMax : xScale.getValueForPixel(chartArea.right);\r\n\r\n\t\t\t\tmodel.ranges[options.xScaleID] = {\r\n\t\t\t\t\tmin: Math.min(min, max),\r\n\t\t\t\t\tmax: Math.max(min, max)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (yScale) {\r\n\t\t\t\tmin = helpers.isValid(options.yMin) ? options.yMin : yScale.getValueForPixel(chartArea.bottom);\r\n\t\t\t\tmax = helpers.isValid(options.yMax) ? options.yMax : yScale.getValueForPixel(chartArea.top);\r\n\r\n\t\t\t\tmodel.ranges[options.yScaleID] = {\r\n\t\t\t\t\tmin: Math.min(min, max),\r\n\t\t\t\t\tmax: Math.max(min, max)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\tconfigure: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\tvar options = this.options;\r\n\t\t\tvar chartInstance = this.chartInstance;\r\n\r\n\t\t\tvar xScale = chartInstance.scales[options.xScaleID];\r\n\t\t\tvar yScale = chartInstance.scales[options.yScaleID];\r\n\t\t\tvar chartArea = chartInstance.chartArea;\r\n\r\n\t\t\t// clip annotations to the chart area\r\n\t\t\tmodel.clip = {\r\n\t\t\t\tx1: chartArea.left,\r\n\t\t\t\tx2: chartArea.right,\r\n\t\t\t\ty1: chartArea.top,\r\n\t\t\t\ty2: chartArea.bottom\r\n\t\t\t};\r\n\r\n\t\t\tvar left = chartArea.left;\r\n\t\t\tvar top = chartArea.top;\r\n\t\t\tvar right = chartArea.right;\r\n\t\t\tvar bottom = chartArea.bottom;\r\n\r\n\t\t\tvar min, max;\r\n\r\n\t\t\tif (xScale) {\r\n\t\t\t\tmin = helpers.isValid(options.xMin) ? xScale.getPixelForValue(options.xMin) : chartArea.left;\r\n\t\t\t\tmax = helpers.isValid(options.xMax) ? xScale.getPixelForValue(options.xMax) : chartArea.right;\r\n\t\t\t\tleft = Math.min(min, max);\r\n\t\t\t\tright = Math.max(min, max);\r\n\t\t\t}\r\n\r\n\t\t\tif (yScale) {\r\n\t\t\t\tmin = helpers.isValid(options.yMin) ? yScale.getPixelForValue(options.yMin) : chartArea.bottom;\r\n\t\t\t\tmax = helpers.isValid(options.yMax) ? yScale.getPixelForValue(options.yMax) : chartArea.top;\r\n\t\t\t\ttop = Math.min(min, max);\r\n\t\t\t\tbottom = Math.max(min, max);\r\n\t\t\t}\r\n\r\n\t\t\t// Ensure model has rect coordinates\r\n\t\t\tmodel.left = left;\r\n\t\t\tmodel.top = top;\r\n\t\t\tmodel.right = right;\r\n\t\t\tmodel.bottom = bottom;\r\n\r\n\t\t\t// Stylistic options\r\n\t\t\tmodel.borderColor = options.borderColor;\r\n\t\t\tmodel.borderWidth = options.borderWidth;\r\n\t\t\tmodel.backgroundColor = options.backgroundColor;\r\n\t\t},\r\n\t\tinRange: function(mouseX, mouseY) {\r\n\t\t\tvar model = this._model;\r\n\t\t\treturn model &&\r\n\t\t\t\tmouseX >= model.left &&\r\n\t\t\t\tmouseX <= model.right &&\r\n\t\t\t\tmouseY >= model.top &&\r\n\t\t\t\tmouseY <= model.bottom;\r\n\t\t},\r\n\t\tgetCenterPoint: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\treturn {\r\n\t\t\t\tx: (model.right + model.left) / 2,\r\n\t\t\t\ty: (model.bottom + model.top) / 2\r\n\t\t\t};\r\n\t\t},\r\n\t\tgetWidth: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\treturn Math.abs(model.right - model.left);\r\n\t\t},\r\n\t\tgetHeight: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\treturn Math.abs(model.bottom - model.top);\r\n\t\t},\r\n\t\tgetArea: function() {\r\n\t\t\treturn this.getWidth() * this.getHeight();\r\n\t\t},\r\n\t\tdraw: function() {\r\n\t\t\tvar view = this._view;\r\n\t\t\tvar ctx = this.chartInstance.chart.ctx;\r\n\r\n\t\t\tctx.save();\r\n\r\n\t\t\t// Canvas setup\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);\r\n\t\t\tctx.clip();\r\n\r\n\t\t\tctx.lineWidth = view.borderWidth;\r\n\t\t\tctx.strokeStyle = view.borderColor;\r\n\t\t\tctx.fillStyle = view.backgroundColor;\r\n\r\n\t\t\t// Draw\r\n\t\t\tvar width = view.right - view.left;\r\n\t\t\tvar height = view.bottom - view.top;\r\n\t\t\tctx.fillRect(view.left, view.top, width, height);\r\n\t\t\tctx.strokeRect(view.left, view.top, width, height);\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t});\r\n\r\n\treturn BoxAnnotation;\r\n};\r\n*/\r\n","import {Element, defaults} from 'chart.js';\r\nimport {isArray} from 'chart.js/helpers/core';\r\nimport {fontString} from 'chart.js/helpers/extras';\r\n\r\nconst PI = Math.PI;\r\nconst HALF_PI = PI / 2;\r\n\r\nexport default class LineAnnotation extends Element {\r\n\r\n\tdraw(ctx) {\r\n\t\tconst {x, y, x2, y2, options} = this;\r\n\t\tctx.save();\r\n\r\n\t\tctx.lineWidth = options.borderWidth;\r\n\t\tctx.strokeStyle = options.borderColor;\r\n\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(options.borderDash);\r\n\t\t}\r\n\t\tctx.lineDashOffset = options.borderDashOffset;\r\n\r\n\t\t// Draw\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x, y);\r\n\t\tctx.lineTo(x2, y2);\r\n\t\tctx.stroke();\r\n\r\n\t\tconst label = options.label;\r\n\t\tif (label && label.enabled && label.content) {\r\n\t\t\tdrawLabel(ctx, this);\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\nLineAnnotation.id = 'lineAnnotation';\r\nLineAnnotation.defaults = {\r\n\tborderDash: [],\r\n\tborderDashOffset: 0,\r\n\tlabel: {\r\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\r\n\t\tfont: {\r\n\t\t\tfamily: defaults.font.family,\r\n\t\t\tsize: defaults.font.size,\r\n\t\t\tstyle: 'bold',\r\n\t\t\tcolor: '#fff',\r\n\t\t},\r\n\t\txPadding: 6,\r\n\t\tyPadding: 6,\r\n\t\trotation: 0,\r\n\t\tcornerRadius: 6,\r\n\t\tposition: 'center',\r\n\t\txAdjust: 0,\r\n\t\tyAdjust: 0,\r\n\t\tenabled: false,\r\n\t\tcontent: null\r\n\t}\r\n};\r\n\r\nfunction drawLabel(ctx, line) {\r\n\tconst label = line.options.label;\r\n\r\n\tctx.font = fontString(\r\n\t\tlabel.font.size,\r\n\t\tlabel.font.style,\r\n\t\tlabel.font.family\r\n\t);\r\n\tctx.textAlign = 'center';\r\n\r\n\tconst {width, height} = measureLabel(ctx, label);\r\n\tconst pos = calculateLabelPosition(line, width, height);\r\n\r\n\tctx.translate(pos.x, pos.y);\r\n\tctx.rotate(label.rotation * PI / 180);\r\n\r\n\tctx.fillStyle = label.backgroundColor;\r\n\troundedRect(ctx, -(width / 2), -(height / 2), width, height, label.cornerRadius);\r\n\tctx.fill();\r\n\r\n\tctx.fillStyle = label.font.color;\r\n\tif (isArray(label.content)) {\r\n\t\tlet textYPosition = -(height / 2) + label.yPadding;\r\n\t\tfor (let i = 0; i < label.content.length; i++) {\r\n\t\t\tctx.textBaseline = 'top';\r\n\t\t\tctx.fillText(\r\n\t\t\t\tlabel.content[i],\r\n\t\t\t\t-(width / 2) + (width / 2),\r\n\t\t\t\ttextYPosition\r\n\t\t\t);\r\n\r\n\t\t\ttextYPosition += label.font.size + label.yPadding;\r\n\t\t}\r\n\t} else {\r\n\t\tctx.textBaseline = 'middle';\r\n\t\tctx.fillText(label.content, 0, 0);\r\n\t}\r\n}\r\n\r\nconst widthCache = new Map();\r\nfunction measureLabel(ctx, label) {\r\n\tconst content = label.content;\r\n\tconst lines = isArray(content) ? content : [content];\r\n\tconst count = lines.length;\r\n\tlet width = 0;\r\n\tfor (let i = 0; i < count; i++) {\r\n\t\tconst text = lines[i];\r\n\t\tif (!widthCache.has(text)) {\r\n\t\t\twidthCache.set(text, ctx.measureText(text).width);\r\n\t\t}\r\n\t\twidth = Math.max(width, widthCache.get(text));\r\n\t}\r\n\twidth += 2 * label.xPadding;\r\n\r\n\treturn {\r\n\t\twidth,\r\n\t\theight: count * label.font.size + ((count + 1) * label.yPadding)\r\n\t};\r\n}\r\n\r\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\r\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\r\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\r\n\r\nfunction calculateLabelPosition(line, width, height) {\r\n\tconst label = line.options.label;\r\n\tconst {xPadding, xAdjust, yPadding, yAdjust} = label;\r\n\tconst p1 = {x: line.x, y: line.y};\r\n\tconst p2 = {x: line.x2, y: line.y2};\r\n\tlet x, y, pt;\r\n\r\n\tswitch (label.position) {\r\n\tcase 'top':\r\n\t\ty = yPadding + yAdjust;\r\n\t\tx = interpolateX(y, p1, p2);\r\n\t\tbreak;\r\n\tcase 'bottom':\r\n\t\ty = height - yPadding + yAdjust;\r\n\t\tx = interpolateX(y, p1, p2);\r\n\t\tbreak;\r\n\tcase 'left':\r\n\t\tx = xPadding + xAdjust;\r\n\t\ty = interpolateY(x, p1, p2);\r\n\t\tbreak;\r\n\tcase 'right':\r\n\t\tx = width - xPadding + xAdjust;\r\n\t\ty = interpolateY(x, p1, p2);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tpt = pointInLine(p1, p2, 0.5);\r\n\t\tx = pt.x + xAdjust;\r\n\t\ty = pt.y + yAdjust;\r\n\t}\r\n\treturn {x, y};\r\n}\r\n\r\n\r\n/**\r\n * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\r\n * given size (width, height) and the same `radius` for all corners.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n * @param {number} x - The x axis of the coordinate for the rectangle starting point.\r\n * @param {number} y - The y axis of the coordinate for the rectangle starting point.\r\n * @param {number} width - The rectangle's width.\r\n * @param {number} height - The rectangle's height.\r\n * @param {number} radius - The rounded amount (in pixels) for the four corners.\r\n * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\r\n */\r\nfunction roundedRect(ctx, x, y, width, height, radius) {\r\n\tif (radius) {\r\n\t\tconst r = Math.min(radius, height / 2, width / 2);\r\n\t\tconst left = x + r;\r\n\t\tconst top = y + r;\r\n\t\tconst right = x + width - r;\r\n\t\tconst bottom = y + height - r;\r\n\r\n\t\tctx.moveTo(x, top);\r\n\t\tif (left < right && top < bottom) {\r\n\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\r\n\t\t\tctx.arc(right, top, r, -HALF_PI, 0);\r\n\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\r\n\t\t\tctx.arc(left, bottom, r, HALF_PI, PI);\r\n\t\t} else if (left < right) {\r\n\t\t\tctx.moveTo(left, y);\r\n\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\r\n\t\t\tctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\r\n\t\t} else if (top < bottom) {\r\n\t\t\tctx.arc(left, top, r, -PI, 0);\r\n\t\t\tctx.arc(left, bottom, r, 0, PI);\r\n\t\t} else {\r\n\t\t\tctx.arc(left, top, r, -PI, PI);\r\n\t\t}\r\n\t\tctx.closePath();\r\n\t\tctx.moveTo(x, y);\r\n\t} else {\r\n\t\tctx.rect(x, y, width, height);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\nexport default function(Chart) {\r\n\tvar chartHelpers = Chart.helpers;\r\n\tvar helpers = require('../helpers.js')(Chart);\r\n\r\n\tvar horizontalKeyword = 'horizontal';\r\n\tvar verticalKeyword = 'vertical';\r\n\r\n\tfunction LineFunction(view) {\r\n\t\t// Describe the line in slope-intercept form (y = mx + b).\r\n\t\t// Note that the axes are rotated 90° CCW, which causes the\r\n\t\t// x- and y-axes to be swapped.\r\n\t\tvar m = (x2 - x) / (y2 - y);\r\n\t\tvar b = x || 0;\r\n\r\n\t\tthis.m = m;\r\n\t\tthis.b = b;\r\n\r\n\t\tthis.getX = function(y) {\r\n\t\t\t// Coordinates are relative to the origin of the canvas\r\n\t\t\treturn m * (y - y) + b;\r\n\t\t};\r\n\r\n\t\tthis.getY = function(x) {\r\n\t\t\treturn ((x - b) / m) + y;\r\n\t\t};\r\n\r\n\t\tthis.intersects = function(x, y, epsilon) {\r\n\t\t\tepsilon = epsilon || 0.001;\r\n\t\t\tvar dy = this.getY(x);\r\n\t\t\tvar dx = this.getX(y);\r\n\t\t\treturn (\r\n\t\t\t\t(!isFinite(dy) || Math.abs(y - dy) < epsilon) &&\r\n\t\t\t\t(!isFinite(dx) || Math.abs(x - dx) < epsilon)\r\n\t\t\t);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction calculateLabelPosition(view, width, height, padWidth, padHeight) {\r\n\t\tvar line = view.line;\r\n\t\tvar ret = {};\r\n\t\tvar xa = 0;\r\n\t\tvar ya = 0;\r\n\r\n\t\tswitch (true) {\r\n\t\t// top align\r\n\t\tcase view.mode === verticalKeyword && view.labelPosition === 'top':\r\n\t\t\tya = padHeight + view.labelYAdjust;\r\n\t\t\txa = (width / 2) + view.labelXAdjust;\r\n\t\t\tret.y = y + ya;\r\n\t\t\tret.x = (isFinite(line.m) ? line.getX(ret.y) : x) - xa;\r\n\t\t\tbreak;\r\n\r\n\t\t// bottom align\r\n\t\tcase view.mode === verticalKeyword && view.labelPosition === 'bottom':\r\n\t\t\tya = height + padHeight + view.labelYAdjust;\r\n\t\t\txa = (width / 2) + view.labelXAdjust;\r\n\t\t\tret.y = y2 - ya;\r\n\t\t\tret.x = (isFinite(line.m) ? line.getX(ret.y) : x) - xa;\r\n\t\t\tbreak;\r\n\r\n\t\t// left align\r\n\t\tcase view.mode === horizontalKeyword && view.labelPosition === 'left':\r\n\t\t\txa = padWidth + view.labelXAdjust;\r\n\t\t\tya = -(height / 2) + view.labelYAdjust;\r\n\t\t\tret.x = x + xa;\r\n\t\t\tret.y = line.getY(ret.x) + ya;\r\n\t\t\tbreak;\r\n\r\n\t\t// right align\r\n\t\tcase view.mode === horizontalKeyword && view.labelPosition === 'right':\r\n\t\t\txa = width + padWidth + view.labelXAdjust;\r\n\t\t\tya = -(height / 2) + view.labelYAdjust;\r\n\t\t\tret.x = x2 - xa;\r\n\t\t\tret.y = line.getY(ret.x) + ya;\r\n\t\t\tbreak;\r\n\r\n\t\t// center align\r\n\t\tdefault:\r\n\t\t\tret.x = ((x + x2 - width) / 2) + view.labelXAdjust;\r\n\t\t\tret.y = ((y + y2 - height) / 2) + view.labelYAdjust;\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tvar LineAnnotation = Chart.Annotation.Element.extend({\r\n\t\tsetDataLimits: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\tvar options = this.options;\r\n\r\n\t\t\t// Set the data range for this annotation\r\n\t\t\tmodel.ranges = {};\r\n\t\t\tmodel.ranges[options.scaleID] = {\r\n\t\t\t\tmin: options.value,\r\n\t\t\t\tmax: options.endValue || options.value\r\n\t\t\t};\r\n\t\t},\r\n\t\tconfigure: function() {\r\n\t\t\tvar model = this._model;\r\n\t\t\tvar options = this.options;\r\n\t\t\tvar chartInstance = this.chartInstance;\r\n\t\t\tvar ctx = chartInstance.chart.ctx;\r\n\r\n\t\t\tvar scale = chartInstance.scales[options.scaleID];\r\n\t\t\tvar pixel, endPixel;\r\n\t\t\tif (scale) {\r\n\t\t\t\tpixel = helpers.isValid(options.value) ? scale.getPixelForValue(options.value, options.value.index) : NaN;\r\n\t\t\t\tendPixel = helpers.isValid(options.endValue) ? scale.getPixelForValue(options.endValue, options.value.index) : pixel;\r\n\t\t\t}\r\n\r\n\t\t\tif (isNaN(pixel)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar chartArea = chartInstance.chartArea;\r\n\r\n\t\t\t// clip annotations to the chart area\r\n\t\t\tmodel.clip = {\r\n\t\t\t\tx1: chartArea.left,\r\n\t\t\t\tx2: chartArea.right,\r\n\t\t\t\ty1: chartArea.top,\r\n\t\t\t\ty2: chartArea.bottom\r\n\t\t\t};\r\n\r\n\t\t\tif (this.options.mode === horizontalKeyword) {\r\n\t\t\t\tmodel.x1 = chartArea.left;\r\n\t\t\t\tmodel.x2 = chartArea.right;\r\n\t\t\t\tmodel.y1 = pixel;\r\n\t\t\t\tmodel.y2 = endPixel;\r\n\t\t\t} else {\r\n\t\t\t\tmodel.y1 = chartArea.top;\r\n\t\t\t\tmodel.y2 = chartArea.bottom;\r\n\t\t\t\tmodel.x1 = pixel;\r\n\t\t\t\tmodel.x2 = endPixel;\r\n\t\t\t}\r\n\r\n\t\t\tmodel.line = new LineFunction(model);\r\n\t\t\tmodel.mode = options.mode;\r\n\r\n\t\t\t// Figure out the label:\r\n\t\t\tmodel.labelBackgroundColor = options.label.backgroundColor;\r\n\t\t\tmodel.labelFontFamily = options.label.fontFamily;\r\n\t\t\tmodel.labelFontSize = options.label.fontSize;\r\n\t\t\tmodel.labelFontStyle = options.label.fontStyle;\r\n\t\t\tmodel.labelFontColor = options.label.fontColor;\r\n\t\t\tmodel.labelXPadding = options.label.xPadding;\r\n\t\t\tmodel.labelYPadding = options.label.yPadding;\r\n\t\t\tmodel.labelCornerRadius = options.label.cornerRadius;\r\n\t\t\tmodel.labelPosition = options.label.position;\r\n\t\t\tmodel.labelXAdjust = options.label.xAdjust;\r\n\t\t\tmodel.labelYAdjust = options.label.yAdjust;\r\n\t\t\tmodel.labelEnabled = options.label.enabled;\r\n\t\t\tmodel.labelContent = options.label.content;\r\n\t\t\tmodel.labelRotation = options.label.rotation;\r\n\r\n\t\t\tctx.font = chartHelpers.fontString(model.labelFontSize, model.labelFontStyle, model.labelFontFamily);\r\n\t\t\tvar textWidth = ctx.measureText(model.labelContent).width;\r\n\t\t\tvar textHeight = model.labelFontSize;\r\n\t\t\tmodel.labelHeight = textHeight + (2 * model.labelYPadding);\r\n\r\n\t\t\tif (model.labelContent && chartHelpers.isArray(model.labelContent)) {\r\n\t\t\t\tvar labelContentArray = model.labelContent.slice(0);\r\n\t\t\t\tvar longestLabel = labelContentArray.sort(function(a, b) {\r\n\t\t\t\t\treturn b.length - a.length;\r\n\t\t\t\t})[0];\r\n\t\t\t\ttextWidth = ctx.measureText(longestLabel).width;\r\n\r\n\t\t\t\tmodel.labelHeight = (textHeight * model.labelContent.length) + (2 * model.labelYPadding);\r\n\t\t\t\t// Add padding in between each label item\r\n\t\t\t\tmodel.labelHeight += model.labelYPadding * (model.labelContent.length - 1);\r\n\t\t\t}\r\n\r\n\t\t\tvar labelPosition = calculateLabelPosition(model, textWidth, textHeight, model.labelXPadding, model.labelYPadding);\r\n\t\t\tmodel.labelX = labelPosition.x - model.labelXPadding;\r\n\t\t\tmodel.labelY = labelPosition.y - model.labelYPadding;\r\n\t\t\tmodel.labelWidth = textWidth + (2 * model.labelXPadding);\r\n\r\n\t\t\tmodel.borderColor = options.borderColor;\r\n\t\t\tmodel.borderWidth = options.borderWidth;\r\n\t\t\tmodel.borderDash = options.borderDash || [];\r\n\t\t\tmodel.borderDashOffset = options.borderDashOffset || 0;\r\n\t\t},\r\n\t\tinRange: function(mouseX, mouseY) {\r\n\t\t\tvar model = this._model;\r\n\r\n\t\t\treturn (\r\n\t\t\t\t// On the line\r\n\t\t\t\tmodel.line &&\r\n\t\t\t\tmodel.line.intersects(mouseX, mouseY, this.getHeight())\r\n\t\t\t) || (\r\n\t\t\t\t// On the label\r\n\t\t\t\tmodel.labelEnabled &&\r\n\t\t\t\tmodel.labelContent &&\r\n\t\t\t\tmouseX >= model.labelX &&\r\n\t\t\t\tmouseX <= model.labelX + model.labelWidth &&\r\n\t\t\t\tmouseY >= model.labelY &&\r\n\t\t\t\tmouseY <= model.labelY + model.labelHeight\r\n\t\t\t);\r\n\t\t},\r\n\t\tgetCenterPoint: function() {\r\n\t\t\treturn {\r\n\t\t\t\tx: (this._model.x2 + this._model.x1) / 2,\r\n\t\t\t\ty: (this._model.y2 + this._model.y1) / 2\r\n\t\t\t};\r\n\t\t},\r\n\t\tgetWidth: function() {\r\n\t\t\treturn Math.abs(this._model.right - this._model.left);\r\n\t\t},\r\n\t\tgetHeight: function() {\r\n\t\t\treturn this._model.borderWidth || 1;\r\n\t\t},\r\n\t\tgetArea: function() {\r\n\t\t\treturn Math.sqrt(Math.pow(this.getWidth(), 2) + Math.pow(this.getHeight(), 2));\r\n\t\t},\r\n\t\tdraw: function() {\r\n\t\t\tvar view = this._view;\r\n\t\t\tvar ctx = this.chartInstance.chart.ctx;\r\n\r\n\t\t\tif (!view.clip) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tctx.save();\r\n\r\n\t\t\t// Canvas setup\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);\r\n\t\t\tctx.clip();\r\n\r\n\t\t\tctx.lineWidth = view.borderWidth;\r\n\t\t\tctx.strokeStyle = view.borderColor;\r\n\r\n\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\tctx.setLineDash(view.borderDash);\r\n\t\t\t}\r\n\t\t\tctx.lineDashOffset = view.borderDashOffset;\r\n\r\n\t\t\t// Draw\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(x2, y2);\r\n\t\t\tctx.stroke();\r\n\r\n\t\t\tif (view.labelEnabled && label.content) {\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.rect(view.clip.x1, view.clip.y1, view.clip.x2 - view.clip.x1, view.clip.y2 - view.clip.y1);\r\n\t\t\t\tctx.clip();\r\n\r\n\t\t\t\tctx.translate(view.labelX + (labelWidth / 2), view.labelY + (labelHeight / 2));\r\n\t\t\t\tctx.rotate(view.labelRotation * Math.PI / 180);\r\n\r\n\t\t\t\tctx.fillStyle = view.labelBackgroundColor;\r\n\t\t\t\t// Draw the tooltip\r\n\t\t\t\tchartHelpers.drawRoundedRectangle(\r\n\t\t\t\t\tctx,\r\n\t\t\t\t\t-(labelWidth / 2), // x\r\n\t\t\t\t\t-(labelHeight / 2), // y\r\n\t\t\t\t\tlabelWidth, // width\r\n\t\t\t\t\tlabelHeight, // height\r\n\t\t\t\t\tview.labelCornerRadius // radius\r\n\t\t\t\t);\r\n\t\t\t\tctx.fill();\r\n\r\n\t\t\t\t// Draw the text\r\n\t\t\t\tctx.font = chartHelpers.fontString(\r\n\t\t\t\t\tview.labelFontSize,\r\n\t\t\t\t\tview.labelFontStyle,\r\n\t\t\t\t\tview.labelFontFamily\r\n\t\t\t\t);\r\n\t\t\t\tctx.fillStyle = view.labelFontColor;\r\n\t\t\t\tctx.textAlign = 'center';\r\n\r\n\t\t\t\tif (label.content && chartHelpers.isArray(label.content)) {\r\n\t\t\t\t\tvar textYPosition = -(labelHeight / 2) + label.yPadding;\r\n\t\t\t\t\tfor (var i = 0; i < label.content.length; i++) {\r\n\t\t\t\t\t\tctx.textBaseline = 'top';\r\n\t\t\t\t\t\tctx.fillText(\r\n\t\t\t\t\t\t\tlabel.content[i],\r\n\t\t\t\t\t\t\t-(labelWidth / 2) + (labelWidth / 2),\r\n\t\t\t\t\t\t\ttextYPosition\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\ttextYPosition += view.labelFontSize + label.yPadding;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.textBaseline = 'middle';\r\n\t\t\t\t\tctx.fillText(label.content, 0, 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.restore();\r\n\t\t}\r\n\t});\r\n\r\n\treturn LineAnnotation;\r\n};\r\n*/\r\n","/*!\n * Chart.js v3.0.0-beta\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n\tif (typeof window === 'undefined') {\n\t\treturn function(callback) {\n\t\t\treturn callback();\n\t\t};\n\t}\n\treturn window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg) {\n\tlet ticking = false;\n\tlet args = [];\n\treturn function(...rest) {\n\t\targs = Array.prototype.slice.call(rest);\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\trequestAnimFrame.call(window, () => {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport { fontString, requestAnimFrame, throttled };\n","import {Animations} from 'chart.js';\r\nimport {clipArea, unclipArea} from 'chart.js/helpers/canvas';\r\nimport {isFinite, merge} from 'chart.js/helpers/core';\r\n\r\nimport BoxAnnotation from './types/box';\r\nimport LineAnnotation from './types/line';\r\n\r\nconst chartElements = new Map();\r\n\r\nconst annotationTypes = {\r\n\tbox: BoxAnnotation,\r\n\tline: LineAnnotation\r\n};\r\n\r\nexport default {\r\n\tid: 'annotation',\r\n\r\n\tafterUpdate(chart, options) {\r\n\t\tupdateElements(chart, options);\r\n\t},\r\n\r\n\tresize(chart, options) {\r\n\t\tupdateElements(chart, options, 'resize');\r\n\t},\r\n\r\n\tbeforeDatasetDraw(chart, options) {\r\n\t\tdraw(chart, options, 'beforeDatasetsDraw');\r\n\t},\r\n\r\n\tafterDatasetsDraw(chart, options) {\r\n\t\tdraw(chart, options, 'afterDatasetsDraw');\r\n\t},\r\n\r\n\tafterDraw(chart, options) {\r\n\t\tdraw(chart, options, 'afterDraw');\r\n\t},\r\n\r\n\tafterEvent(chart, event, _replay, options) {\r\n\t\tconst events = options.events || [];\r\n\t\tif (events.indexOf(event.type) !== -1) {\r\n\t\t\thandleEvent(chart, event, options);\r\n\t\t}\r\n\t},\r\n\r\n\tdestroy(chart) {\r\n\t\tchartElements.remove(chart);\r\n\t},\r\n\r\n\tdefaults: {\r\n\t\tdrawTime: 'afterDatasetsDraw',\r\n\t\tdblClickSpeed: 350, // ms\r\n\t\tevents: [],\r\n\t\tannotations: [],\r\n\t\tanimation: {\r\n\t\t\tnumbers: {\r\n\t\t\t\tproperties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\r\n\t\t\t\ttype: 'number'\r\n\t\t\t},\r\n\t\t}\r\n\t},\r\n};\r\n\r\nfunction updateElements(chart, options, mode) {\r\n\tconst chartAnims = chart.options.animation;\r\n\tconst animOpts = chartAnims && merge({}, [chartAnims, options.animation]);\r\n\tconst animations = new Animations(chart, animOpts, mode);\r\n\r\n\tconst elements = chartElements.get(chart) || (chartElements.set(chart, []).get(chart));\r\n\tconst annotations = options.annotations || [];\r\n\tconst count = annotations.length;\r\n\tconst start = elements.length;\r\n\r\n\tif (start < count) {\r\n\t\tconst add = count - start;\r\n\t\telements.splice(start, 0, ...new Array(add));\r\n\t} else if (start > count) {\r\n\t\telements.splice(count, start - count);\r\n\t}\r\n\tfor (let i = 0; i < annotations.length; i++) {\r\n\t\tconst annotation = annotations[i];\r\n\t\tlet el = elements[i];\r\n\t\tconst elType = annotationTypes[annotation.type] || annotationTypes.line;\r\n\t\tif (!el || !(el instanceof elType)) {\r\n\t\t\tel = elements[i] = new elType();\r\n\t\t}\r\n\t\tconst properties = calculateElementProperties(chart, annotation, elType.defaults);\r\n\t\tanimations.update(el, properties);\r\n\t}\r\n}\r\n\r\nconst scaleValue = (scale, value, fallback) => isFinite(value) ? scale.getPixelForValue(value) : fallback;\r\n\r\nfunction calculateElementProperties(chart, options, defaults) {\r\n\tconst scale = chart.scales[options.scaleID];\r\n\r\n\tlet {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\r\n\tlet min, max;\r\n\r\n\tif (scale) {\r\n\t\tmin = scaleValue(scale, options.value, NaN);\r\n\t\tmax = scaleValue(scale, options.endValue, min);\r\n\t\tif (scale.isHorizontal()) {\r\n\t\t\tx = Math.min(min, max);\r\n\t\t\tx2 = Math.max(min, max);\r\n\t\t} else {\r\n\t\t\ty = Math.min(min, max);\r\n\t\t\ty2 = Math.max(min, max);\r\n\t\t}\r\n\t} else {\r\n\t\tconst xScale = chart.scales[options.xScaleID];\r\n\t\tconst yScale = chart.scales[options.yScaleID];\r\n\r\n\t\tif (xScale) {\r\n\t\t\tmin = scaleValue(xScale, options.xMin, x);\r\n\t\t\tmax = scaleValue(xScale, options.xMax, x2);\r\n\t\t\tx = Math.min(min, max);\r\n\t\t\tx2 = Math.max(min, max);\r\n\t\t}\r\n\r\n\t\tif (yScale) {\r\n\t\t\tmin = scaleValue(yScale, options.yMin, y2);\r\n\t\t\tmax = scaleValue(yScale, options.yMax, y);\r\n\t\t\ty = Math.min(min, max);\r\n\t\t\ty2 = Math.max(min, max);\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tx,\r\n\t\ty,\r\n\t\tx2,\r\n\t\ty2,\r\n\t\twidth: x2 - x,\r\n\t\theight: y2 - y,\r\n\t\toptions: merge({}, [defaults, options])\r\n\t};\r\n}\r\n\r\nfunction draw(chart, options, caller) {\r\n\tif (options.drawTime !== caller) {\r\n\t\treturn;\r\n\t}\r\n\tconst {ctx, chartArea} = chart;\r\n\tconst elements = chartElements.get(chart);\r\n\r\n\tclipArea(ctx, chartArea)\r\n\tfor (let i = 0; i < elements.length; i++) {\r\n\t\tconst el = elements[i];\r\n\t\tif ((el.options.drawTime || caller) === caller) {\r\n\t\t\tel.draw(ctx);\r\n\t\t}\r\n\t}\r\n\tunclipArea(ctx);\r\n}\r\n\r\n/*\r\nexport default function(Chart) {\r\n\tvar chartHelpers = Chart.helpers;\r\n\r\n\tvar helpers = require('./helpers.js')(Chart);\r\n\tvar events = require('./events.js')(Chart);\r\n\r\n\tvar annotationTypes = Chart.Annotation.types;\r\n\r\n\tfunction setAfterDataLimitsHook(axisOptions) {\r\n\t\thelpers.decorate(axisOptions, 'afterDataLimits', function(previous, scale) {\r\n\t\t\tif (previous) {\r\n\t\t\t\tprevious(scale);\r\n\t\t\t}\r\n\t\t\thelpers.adjustScaleRange(scale);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction draw(drawTime) {\r\n\t\treturn function(chartInstance, easingDecimal) {\r\n\t\t\tvar defaultDrawTime = chartInstance.annotation.options.drawTime;\r\n\r\n\t\t\thelpers.elements(chartInstance)\r\n\t\t\t\t.filter(function(element) {\r\n\t\t\t\t\treturn drawTime === (element.options.drawTime || defaultDrawTime);\r\n\t\t\t\t})\r\n\t\t\t\t.forEach(function(element) {\r\n\t\t\t\t\telement.configure();\r\n\t\t\t\t\telement.transition(easingDecimal).draw();\r\n\t\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tfunction getAnnotationConfig(chartOptions) {\r\n\t\tvar plugins = chartOptions.plugins;\r\n\t\tvar pluginAnnotation = plugins && plugins.annotation ? plugins.annotation : null;\r\n\t\treturn pluginAnnotation || chartOptions.annotation || {};\r\n\t}\r\n\r\n\treturn {\r\n\t\tid: 'annotation',\r\n\t\tbeforeInit: function(chartInstance) {\r\n\t\t\tvar chartOptions = chartInstance.options;\r\n\r\n\t\t\t// Initialize chart instance plugin namespace\r\n\t\t\tvar ns = chartInstance.annotation = {\r\n\t\t\t\telements: {},\r\n\t\t\t\toptions: helpers.initConfig(getAnnotationConfig(chartOptions)),\r\n\t\t\t\tonDestroy: [],\r\n\t\t\t\tfirstRun: true,\r\n\t\t\t\tsupported: false\r\n\t\t\t};\r\n\r\n\t\t\t// Add the annotation scale adjuster to each scale's afterDataLimits hook\r\n\t\t\tchartInstance.ensureScalesHaveIDs();\r\n\t\t\tif (chartOptions.scales) {\r\n\t\t\t\tns.supported = true;\r\n\t\t\t\tchartHelpers.each(chartOptions.scales.xAxes, setAfterDataLimitsHook);\r\n\t\t\t\tchartHelpers.each(chartOptions.scales.yAxes, setAfterDataLimitsHook);\r\n\t\t\t}\r\n\t\t},\r\n\t\tbeforeUpdate: function(chartInstance) {\r\n\t\t\tvar ns = chartInstance.annotation;\r\n\r\n\t\t\tif (!ns.supported) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!ns.firstRun) {\r\n\t\t\t\tns.options = helpers.initConfig(getAnnotationConfig(chartInstance.options));\r\n\t\t\t} else {\r\n\t\t\t\tns.firstRun = false;\r\n\t\t\t}\r\n\r\n\t\t\tvar elementIds = [];\r\n\r\n\t\t\t// Add new elements, or update existing ones\r\n\t\t\tns.options.annotations.forEach(function(annotation) {\r\n\t\t\t\tvar id = annotation.id || helpers.objectId();\r\n\r\n\t\t\t\t// No element with that ID exists, and it's a valid annotation type\r\n\t\t\t\tif (!ns.elements[id] && annotationTypes[annotation.type]) {\r\n\t\t\t\t\tvar cls = annotationTypes[annotation.type];\r\n\t\t\t\t\tvar element = new cls({\r\n\t\t\t\t\t\tid: id,\r\n\t\t\t\t\t\toptions: annotation,\r\n\t\t\t\t\t\tchartInstance: chartInstance,\r\n\t\t\t\t\t});\r\n\t\t\t\t\telement.initialize();\r\n\t\t\t\t\tns.elements[id] = element;\r\n\t\t\t\t\tannotation.id = id;\r\n\t\t\t\t\telementIds.push(id);\r\n\t\t\t\t} else if (ns.elements[id]) {\r\n\t\t\t\t\t// Nothing to do for update, since the element config references\r\n\t\t\t\t\t// the same object that exists in the chart annotation config\r\n\t\t\t\t\telementIds.push(id);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Delete removed elements\r\n\t\t\tObject.keys(ns.elements).forEach(function(id) {\r\n\t\t\t\tif (elementIds.indexOf(id) === -1) {\r\n\t\t\t\t\tns.elements[id].destroy();\r\n\t\t\t\t\tdelete ns.elements[id];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\tbeforeDatasetsDraw: draw('beforeDatasetsDraw'),\r\n\t\tafterDatasetsDraw: draw('afterDatasetsDraw'),\r\n\t\tafterDraw: draw('afterDraw'),\r\n\t\tafterInit: function(chartInstance) {\r\n\t\t\t// Detect and intercept events that happen on an annotation element\r\n\t\t\tvar watchFor = chartInstance.annotation.options.events;\r\n\t\t\tif (chartHelpers.isArray(watchFor) && watchFor.length > 0) {\r\n\t\t\t\tvar canvas = chartInstance.chart.canvas;\r\n\t\t\t\tvar eventHandler = events.dispatcher.bind(chartInstance);\r\n\t\t\t\tevents.collapseHoverEvents(watchFor).forEach(function(eventName) {\r\n\t\t\t\t\tchartHelpers.addEvent(canvas, eventName, eventHandler);\r\n\t\t\t\t\tchartInstance.annotation.onDestroy.push(function() {\r\n\t\t\t\t\t\tchartHelpers.removeEvent(canvas, eventName, eventHandler);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\t\tdestroy: function(chartInstance) {\r\n\t\t\tif (!chartInstance || !chartInstance.annotation) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar deregisterers = chartInstance.annotation.onDestroy;\r\n\t\t\twhile (deregisterers.length > 0) {\r\n\t\t\t\tderegisterers.pop()();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n*/\r\n","/*!\n * Chart.js v3.0.0-beta\n * https://www.chartjs.org\n * (c) 2020 Chart.js Contributors\n * Released under the MIT License\n */\nimport { isNullOrUndef, isArray } from './core.js';\n\nconst PI = Math.PI;\nconst RAD_PER_DEG = PI / 180;\nconst DOUBLE_PI = PI * 2;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nfunction toFontString(font) {\n\tif (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n\t\treturn null;\n\t}\n\treturn (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n\tlet textWidth = data[string];\n\tif (!textWidth) {\n\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\tgc.push(string);\n\t}\n\tif (textWidth > longest) {\n\t\tlongest = textWidth;\n\t}\n\treturn longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n\tcache = cache || {};\n\tlet data = cache.data = cache.data || {};\n\tlet gc = cache.garbageCollect = cache.garbageCollect || [];\n\tif (cache.font !== font) {\n\t\tdata = cache.data = {};\n\t\tgc = cache.garbageCollect = [];\n\t\tcache.font = font;\n\t}\n\tctx.save();\n\tctx.font = font;\n\tlet longest = 0;\n\tconst ilen = arrayOfThings.length;\n\tlet i, j, jlen, thing, nestedThing;\n\tfor (i = 0; i < ilen; i++) {\n\t\tthing = arrayOfThings[i];\n\t\tif (thing !== undefined && thing !== null && isArray(thing) !== true) {\n\t\t\tlongest = _measureText(ctx, data, gc, longest, thing);\n\t\t} else if (isArray(thing)) {\n\t\t\tfor (j = 0, jlen = thing.length; j < jlen; j++) {\n\t\t\t\tnestedThing = thing[j];\n\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n\t\t\t\t\tlongest = _measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tctx.restore();\n\tconst gcLen = gc.length / 2;\n\tif (gcLen > arrayOfThings.length) {\n\t\tfor (i = 0; i < gcLen; i++) {\n\t\t\tdelete data[gc[i]];\n\t\t}\n\t\tgc.splice(0, gcLen);\n\t}\n\treturn longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n\tconst devicePixelRatio = chart.currentDevicePixelRatio;\n\tconst halfWidth = width / 2;\n\treturn Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clear(chart) {\n\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n}\nfunction drawPoint(ctx, options, x, y) {\n\tlet type, xOffset, yOffset, size, cornerRadius;\n\tconst style = options.pointStyle;\n\tconst rotation = options.rotation;\n\tconst radius = options.radius;\n\tlet rad = (rotation || 0) * RAD_PER_DEG;\n\tif (style && typeof style === 'object') {\n\t\ttype = style.toString();\n\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\tctx.save();\n\t\t\tctx.translate(x, y);\n\t\t\tctx.rotate(rad);\n\t\t\tctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n\t\t\tctx.restore();\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isNaN(radius) || radius <= 0) {\n\t\treturn;\n\t}\n\tctx.beginPath();\n\tswitch (style) {\n\tdefault:\n\t\tctx.arc(x, y, radius, 0, DOUBLE_PI);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'triangle':\n\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\trad += TWO_THIRDS_PI;\n\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\trad += TWO_THIRDS_PI;\n\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'rectRounded':\n\t\tcornerRadius = radius * 0.516;\n\t\tsize = radius - cornerRadius;\n\t\txOffset = Math.cos(rad + QUARTER_PI) * size;\n\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\n\t\tctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n\t\tctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n\t\tctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n\t\tctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'rect':\n\t\tif (!rotation) {\n\t\t\tsize = Math.SQRT1_2 * radius;\n\t\t\tctx.rect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\t}\n\t\trad += QUARTER_PI;\n\tcase 'rectRot':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tctx.closePath();\n\t\tbreak;\n\tcase 'crossRot':\n\t\trad += QUARTER_PI;\n\tcase 'cross':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tbreak;\n\tcase 'star':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\trad += QUARTER_PI;\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\tbreak;\n\tcase 'line':\n\t\txOffset = Math.cos(rad) * radius;\n\t\tyOffset = Math.sin(rad) * radius;\n\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\tbreak;\n\tcase 'dash':\n\t\tctx.moveTo(x, y);\n\t\tctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n\t\tbreak;\n\t}\n\tctx.fill();\n\tif (options.borderWidth > 0) {\n\t\tctx.stroke();\n\t}\n}\nfunction _isPointInArea(point, area) {\n\tconst epsilon = 0.5;\n\treturn point.x > area.left - epsilon && point.x < area.right + epsilon &&\n\t\tpoint.y > area.top - epsilon && point.y < area.bottom + epsilon;\n}\nfunction clipArea(ctx, area) {\n\tctx.save();\n\tctx.beginPath();\n\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\tctx.clip();\n}\nfunction unclipArea(ctx) {\n\tctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n\tif (!previous) {\n\t\treturn ctx.lineTo(target.x, target.y);\n\t}\n\tif (mode === 'middle') {\n\t\tconst midpoint = (previous.x + target.x) / 2.0;\n\t\tctx.lineTo(midpoint, previous.y);\n\t\tctx.lineTo(midpoint, target.y);\n\t} else if (mode === 'after' !== !!flip) {\n\t\tctx.lineTo(previous.x, target.y);\n\t} else {\n\t\tctx.lineTo(target.x, previous.y);\n\t}\n\tctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n\tif (!previous) {\n\t\treturn ctx.lineTo(target.x, target.y);\n\t}\n\tctx.bezierCurveTo(\n\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\ttarget.x,\n\t\ttarget.y);\n}\n\nexport { _alignPixel, _bezierCurveTo, _isPointInArea, _longestText, _measureText, _steppedLineTo, clear, clipArea, drawPoint, toFontString, unclipArea };\n","import {Chart} from 'chart.js';\r\nimport Annotation from './annotation';\r\nimport BoxAnnotation from './types/box';\r\nimport LineAnnotation from './types/line';\r\n\r\nChart.register(Annotation, BoxAnnotation, LineAnnotation);\r\n\r\nexport default Annotation;\r\n"],"names":["isArray","value","Array","type","Object","prototype","toString","call","substr","isObject","clone","source","map","target","keys","klen","length","k","_merger","key","options","tval","sval","merge","sources","ilen","merger","i","BoxAnnotation","Element","[object Object]","mouseX","mouseY","useFinalPosition","x","y","width","height","this","getProps","ctx","save","lineWidth","borderWidth","strokeStyle","borderColor","fillStyle","backgroundColor","fillRect","strokeRect","restore","id","defaults","defaultRoutes","PI","Math","HALF_PI","LineAnnotation","x2","y2","setLineDash","borderDash","lineDashOffset","borderDashOffset","beginPath","moveTo","lineTo","stroke","label","enabled","content","line","font","pixelSize","size","fontStyle","style","fontFamily","family","textAlign","lines","count","text","widthCache","has","set","measureText","max","get","xPadding","yPadding","measureLabel","pos","xAdjust","yAdjust","p1","p2","pt","position","interpolateX","interpolateY","pointInLine","calculateLabelPosition","translate","rotate","rotation","radius","r","min","left","top","right","bottom","arc","closePath","rect","roundedRect","cornerRadius","fill","color","textYPosition","textBaseline","fillText","drawLabel","Map","t","abs","chartElements","annotationTypes","box","chart","updateElements","draw","event","_replay","events","indexOf","handleEvent","remove","drawTime","dblClickSpeed","annotations","animation","numbers","properties","mode","chartAnims","animOpts","animations","Animations","elements","start","add","splice","annotation","el","elType","calculateElementProperties","update","scaleValue","scale","fallback","Number","isFinite","getPixelForValue","scales","scaleID","chartArea","NaN","endValue","isHorizontal","xScale","xScaleID","yScale","yScaleID","xMin","xMax","yMin","yMax","caller","area","clip","clipArea","unclipArea","Chart","register","Annotation"],"mappings":"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"}